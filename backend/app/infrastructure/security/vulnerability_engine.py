"""
CyberGuardX - Advanced Vulnerability Engine
===========================================
Professional-grade vulnerability analysis engine with risk prioritization
and actionable remediation guidance.
"""

from typing import Dict, List, Any, Optional
from datetime import datetime
import re
import hashlib

from .vulnerability_data import VULNERABILITIES


class AdvancedVulnerabilityEngine:
    """
    Professional-grade vulnerability analysis engine.
    Enriches scan results with deep explanations, risk prioritization,
    and actionable remediation guidance.
    """

    def __init__(self):
        self.knowledge = VULNERABILITIES
        
        # Pre-build indexes for O(1) lookups instead of O(n) linear search
        self.by_category = {}
        self.by_severity = {}
        self.by_id = {}
        
        for vuln_id, vuln in self.knowledge.items():
            # Index by ID (direct access)
            self.by_id[vuln_id] = vuln
            
            # Index by category
            category = vuln.get('category', 'Unknown')
            if category not in self.by_category:
                self.by_category[category] = []
            self.by_category[category].append(vuln)
            
            # Index by severity
            severity = vuln.get('severity', 'UNKNOWN')
            if severity not in self.by_severity:
                self.by_severity[severity] = []
            self.by_severity[severity].append(vuln)
        
        logger_info = f"Vulnerability engine initialized: {len(self.knowledge)} vulnerabilities indexed"
        logger_info += f" | Categories: {len(self.by_category)} | Severities: {len(self.by_severity)}"
        print(logger_info)
        
        self.waf_signatures = {
            "Cloudflare": ["cf-ray", "cf-cache-status", "__cfduid", "cf-request-id"],
            "AWS WAF": ["x-amzn-requestid", "x-amz-cf-id"],
            "Akamai": ["x-akamai-transformed", "akamai"],
            "Imperva/Incapsula": ["x-cdn", "incap_ses", "visid_incap"],
            "Sucuri": ["x-sucuri-id", "x-sucuri-cache"],
            "F5 BIG-IP": ["x-cnection", "bigipserver"],
            "Barracuda": ["barra_counter_session"],
            "ModSecurity": ["mod_security", "NOYB"],
        }

    def analyze(
        self,
        http_scan: Dict,
        ssl_scan: Dict,
        dns_scan: Dict,
        tech_scan: Dict
    ) -> Dict[str, Any]:
        """
        Perform deep vulnerability analysis on all scan results.

        Returns enriched vulnerability report with:
        - Detailed vulnerability explanations
        - CWE/CVE mappings
        - Impact scoring and exploit difficulty
        - Real-world examples
        - Fix instructions for nginx/apache/nodejs/iis
        - Risk prioritization with timeframes
        - Compliance mapping
        - Security scorecard
        """
        vulnerabilities = []

        # Analyze HTTP headers
        vulnerabilities.extend(self._analyze_http(http_scan))

        # Analyze SSL/TLS
        vulnerabilities.extend(self._analyze_ssl(ssl_scan))

        # Analyze DNS
        vulnerabilities.extend(self._analyze_dns(dns_scan))

        # Analyze server configuration
        vulnerabilities.extend(self._analyze_server(http_scan, tech_scan))

        # WAF detection
        waf_result = self._detect_waf(http_scan)

        # Sort by CVSS score descending
        vulnerabilities.sort(key=lambda v: v.get("cvss_score", 0), reverse=True)

        # Build risk prioritization dashboard
        prioritization = self._build_prioritization(vulnerabilities)

        # Build security scorecard
        scorecard = self._build_scorecard(vulnerabilities, http_scan, ssl_scan, dns_scan, tech_scan)

        # Compliance summary
        compliance = self._build_compliance_summary(vulnerabilities)

        return {
            "analysis_timestamp": datetime.utcnow().isoformat(),
            "total_vulnerabilities": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "waf_detection": waf_result,
            "risk_prioritization": prioritization,
            "security_scorecard": scorecard,
            "compliance_summary": compliance,
            "severity_counts": {
                "critical": sum(1 for v in vulnerabilities if v["severity"] == "CRITICAL"),
                "high": sum(1 for v in vulnerabilities if v["severity"] == "HIGH"),
                "medium": sum(1 for v in vulnerabilities if v["severity"] == "MEDIUM"),
                "low": sum(1 for v in vulnerabilities if v["severity"] == "LOW"),
            }
        }

    def _analyze_http(self, http_scan: Dict) -> List[Dict]:
        """Analyze HTTP header vulnerabilities with deep explanations."""
        vulns = []
        if not http_scan.get("success"):
            return vulns

        header_analysis = http_scan.get("header_analysis", {})

        header_vuln_map = {
            "Content-Security-Policy": ("MISSING_CSP", "WEAK_CSP"),
            "Strict-Transport-Security": ("MISSING_HSTS", None),
            "X-Frame-Options": ("MISSING_X_FRAME_OPTIONS", None),
            "X-Content-Type-Options": ("MISSING_X_CONTENT_TYPE", None),
            "Referrer-Policy": ("MISSING_REFERRER_POLICY", None),
            "Permissions-Policy": ("MISSING_PERMISSIONS_POLICY", None),
        }

        for header_name, (missing_key, weak_key) in header_vuln_map.items():
            if header_name in header_analysis:
                analysis = header_analysis[header_name]
                if not analysis.get("present"):
                    if missing_key in self.knowledge:
                        vulns.append(self._enrich_vulnerability(missing_key, {
                            "detected_value": "Not present",
                            "header": header_name
                        }))
                elif weak_key and analysis.get("score", 100) < 70:
                    if weak_key in self.knowledge:
                        vulns.append(self._enrich_vulnerability(weak_key, {
                            "detected_value": analysis.get("value", ""),
                            "score": analysis.get("score", 0),
                            "header": header_name
                        }))

        # Check CORS
        all_headers = http_scan.get("all_headers", {})
        cors_origin = all_headers.get("Access-Control-Allow-Origin", "")
        if cors_origin == "*":
            vulns.append(self._enrich_vulnerability("CORS_MISCONFIGURATION", {
                "detected_value": cors_origin
            }))

        return vulns

    def _analyze_ssl(self, ssl_scan: Dict) -> List[Dict]:
        """Analyze SSL/TLS vulnerabilities with deep explanations."""
        vulns = []

        if ssl_scan.get("error") and "not HTTPS" in str(ssl_scan.get("error", "")):
            vulns.append(self._enrich_vulnerability("NO_HTTPS", {}))
            return vulns

        if not ssl_scan.get("success"):
            return vulns

        cert = ssl_scan.get("certificate", {})

        # Expired certificate
        if cert.get("expired"):
            vulns.append(self._enrich_vulnerability("EXPIRED_CERTIFICATE", {
                "expiry_date": cert.get("valid_to", "Unknown")
            }))

        # Expiring soon
        days_left = cert.get("days_until_expiry", 999)
        if 0 < days_left <= 30:
            vulns.append(self._enrich_vulnerability("CERTIFICATE_EXPIRING_SOON", {
                "days_remaining": days_left,
                "expiry_date": cert.get("valid_to", "Unknown")
            }))

        # Weak TLS
        tls_version = ssl_scan.get("tls_version", "")
        if tls_version and tls_version in ["TLSv1.0", "TLSv1.1", "SSLv3"]:
            vulns.append(self._enrich_vulnerability("WEAK_TLS_VERSION", {
                "detected_version": tls_version
            }))

        # Weak ciphers
        # NOTE: SSL scanner stores the key as "cipher_suite", not "cipher"
        cipher = ssl_scan.get("cipher_suite", "")
        if cipher:
            cipher_name = cipher[0] if isinstance(cipher, (list, tuple)) else str(cipher)
            weak_indicators = ["RC4", "DES", "MD5", "NULL", "EXPORT", "anon"]
            if any(w in cipher_name.upper() for w in weak_indicators):
                vulns.append(self._enrich_vulnerability("WEAK_CIPHER_SUITE", {
                    "detected_cipher": cipher_name
                }))

        # Missing HSTS (from SSL perspective)
        if not ssl_scan.get("hsts", {}).get("present"):
            has_hsts_vuln = any(v.get("vuln_key") == "MISSING_HSTS" for v in vulns)
            if not has_hsts_vuln:
                vulns.append(self._enrich_vulnerability("MISSING_HSTS", {
                    "detected_value": "HSTS not present in SSL check"
                }))

        return vulns

    def _analyze_dns(self, dns_scan: Dict) -> List[Dict]:
        """Analyze DNS security vulnerabilities."""
        vulns = []
        if not dns_scan.get("success"):
            return vulns

        if not dns_scan.get("spf", {}).get("present"):
            vulns.append(self._enrich_vulnerability("MISSING_SPF", {}))

        if not dns_scan.get("dmarc", {}).get("present"):
            vulns.append(self._enrich_vulnerability("MISSING_DMARC", {}))

        if not dns_scan.get("dnssec", {}).get("enabled"):
            vulns.append(self._enrich_vulnerability("MISSING_DNSSEC", {}))

        return vulns

    def _analyze_server(self, http_scan: Dict, tech_scan: Dict) -> List[Dict]:
        """Analyze server configuration vulnerabilities."""
        vulns = []

        # Server version disclosure
        if tech_scan.get("success") and tech_scan.get("web_server_version"):
            vulns.append(self._enrich_vulnerability("SERVER_VERSION_DISCLOSURE", {
                "server": tech_scan.get("web_server", "Unknown"),
                "version": tech_scan.get("web_server_version", "Unknown")
            }))

        return vulns

    def _detect_waf(self, http_scan: Dict) -> Dict:
        """Detect Web Application Firewall presence."""
        all_headers = http_scan.get("all_headers", {})
        if not all_headers:
            all_headers = {}

        detected_wafs = []
        headers_str = str(all_headers).lower()

        for waf_name, signatures in self.waf_signatures.items():
            for sig in signatures:
                if sig.lower() in headers_str:
                    detected_wafs.append(waf_name)
                    break

        has_waf = len(detected_wafs) > 0

        result = {
            "waf_detected": has_waf,
            "detected_wafs": detected_wafs,
            "protection_level": "PROTECTED" if has_waf else "UNPROTECTED"
        }

        if not has_waf:
            result["recommendation"] = self.knowledge.get("WAF_NOT_DETECTED", {})

        return result

    def _enrich_vulnerability(self, vuln_key: str, context: Dict) -> Dict:
        """Enrich a vulnerability with full knowledge base data."""
        kb = self.knowledge.get(vuln_key, {})
        return {
            "vuln_key": vuln_key,
            "id": kb.get("id", "UNKNOWN"),
            "title": kb.get("title", vuln_key),
            "cwe_id": kb.get("cwe_id", ""),
            "cvss_score": kb.get("cvss_score", 0),
            "severity": kb.get("severity", "UNKNOWN"),
            "category": kb.get("category", "Unknown"),
            "owasp": kb.get("owasp", ""),
            "simple_explanation": kb.get("simple_explanation", ""),
            "technical_detail": kb.get("technical_detail", ""),
            "impact_score": kb.get("impact_score", 0),
            "exploit_difficulty": kb.get("exploit_difficulty", "UNKNOWN"),
            "real_world_example": kb.get("real_world_example", ""),
            "fix_instructions": kb.get("fix_instructions", {}),
            "priority_timeframe": kb.get("priority_timeframe", "N/A"),
            "compliance": kb.get("compliance", []),
            "context": context
        }

    def _build_prioritization(self, vulnerabilities: List[Dict]) -> Dict:
        """Build risk prioritization dashboard."""
        immediate = []
        within_24h = []
        within_7d = []
        within_30d = []
        consider = []

        for vuln in vulnerabilities:
            entry = {
                "id": vuln["id"],
                "title": vuln["title"],
                "severity": vuln["severity"],
                "cvss_score": vuln["cvss_score"]
            }
            tf = vuln.get("priority_timeframe", "N/A")
            if tf == "IMMEDIATE":
                immediate.append(entry)
            elif "24 hour" in tf:
                within_24h.append(entry)
            elif "7 day" in tf:
                within_7d.append(entry)
            elif "30 day" in tf:
                within_30d.append(entry)
            else:
                consider.append(entry)

        return {
            "immediate": immediate,
            "within_24_hours": within_24h,
            "within_7_days": within_7d,
            "within_30_days": within_30d,
            "consider": consider,
            "total_action_items": len(vulnerabilities)
        }

    def _build_scorecard(
        self,
        vulnerabilities: List[Dict],
        http_scan: Dict,
        ssl_scan: Dict,
        dns_scan: Dict,
        tech_scan: Dict
    ) -> Dict:
        """Build user-friendly security scorecard."""
        categories = {
            "Transport Security": {"score": 100, "grade": "A", "issues": []},
            "Header Security": {"score": 100, "grade": "A", "issues": []},
            "DNS & Email Security": {"score": 100, "grade": "A", "issues": []},
            "Server Hardening": {"score": 100, "grade": "A", "issues": []},
            "WAF Protection": {"score": 100, "grade": "A", "issues": []},
        }

        for vuln in vulnerabilities:
            cat = vuln.get("category", "")
            deduction = vuln.get("impact_score", 0) * 3

            if cat == "SSL/TLS":
                categories["Transport Security"]["score"] = max(0, categories["Transport Security"]["score"] - deduction)
                categories["Transport Security"]["issues"].append(vuln["title"])
            elif cat == "HTTP Headers":
                categories["Header Security"]["score"] = max(0, categories["Header Security"]["score"] - deduction)
                categories["Header Security"]["issues"].append(vuln["title"])
            elif cat == "DNS Security":
                categories["DNS & Email Security"]["score"] = max(0, categories["DNS & Email Security"]["score"] - deduction)
                categories["DNS & Email Security"]["issues"].append(vuln["title"])
            elif cat == "Server Configuration":
                categories["Server Hardening"]["score"] = max(0, categories["Server Hardening"]["score"] - deduction)
                categories["Server Hardening"]["issues"].append(vuln["title"])

        # Assign grades
        for cat_name, cat_data in categories.items():
            score = cat_data["score"]
            if score >= 90:
                cat_data["grade"] = "A"
            elif score >= 75:
                cat_data["grade"] = "B"
            elif score >= 60:
                cat_data["grade"] = "C"
            elif score >= 40:
                cat_data["grade"] = "D"
            else:
                cat_data["grade"] = "F"

        # Overall score
        overall = sum(c["score"] for c in categories.values()) / len(categories)

        return {
            "overall_score": round(overall),
            "overall_grade": "A" if overall >= 90 else "B" if overall >= 75 else "C" if overall >= 60 else "D" if overall >= 40 else "F",
            "categories": categories
        }

    def _build_compliance_summary(self, vulnerabilities: List[Dict]) -> Dict:
        """Build compliance framework summary."""
        frameworks = {
            "PCI-DSS": {"status": "COMPLIANT", "violations": [], "description": "Payment Card Industry Data Security Standard"},
            "GDPR": {"status": "COMPLIANT", "violations": [], "description": "General Data Protection Regulation (EU)"},
            "HIPAA": {"status": "COMPLIANT", "violations": [], "description": "Health Insurance Portability and Accountability Act"},
            "SOC 2": {"status": "COMPLIANT", "violations": [], "description": "Service Organization Control Type 2"},
            "NIST": {"status": "COMPLIANT", "violations": [], "description": "NIST Cybersecurity Framework"},
            "OWASP ASVS": {"status": "COMPLIANT", "violations": [], "description": "OWASP Application Security Verification Standard"},
        }

        for vuln in vulnerabilities:
            for comp in vuln.get("compliance", []):
                for fw_name in frameworks:
                    if fw_name.lower().replace("-", "").replace(" ", "") in comp.lower().replace("-", "").replace(" ", ""):
                        frameworks[fw_name]["violations"].append({
                            "vuln_id": vuln["id"],
                            "title": vuln["title"],
                            "requirement": comp,
                            "severity": vuln["severity"]
                        })
                        frameworks[fw_name]["status"] = "NON-COMPLIANT"

        compliant_count = sum(1 for f in frameworks.values() if f["status"] == "COMPLIANT")

        return {
            "frameworks": frameworks,
            "compliant_count": compliant_count,
            "total_frameworks": len(frameworks),
            "compliance_percentage": round((compliant_count / len(frameworks)) * 100)
        }
