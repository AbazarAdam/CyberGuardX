"""
CyberGuardX - Advanced Vulnerability Engine
Professional-grade vulnerability knowledge base with deep explanations,
CWE/CVE mappings, impact scoring, and remediation guidance.
"""

from typing import Dict, List, Any, Optional
from datetime import datetime
import re
import hashlib


class VulnerabilityKnowledge:
    """Comprehensive vulnerability knowledge base with deep explanations."""

    VULNERABILITIES = {
        # ===== HTTP HEADER VULNERABILITIES =====
        "MISSING_CSP": {
            "id": "VULN-HTTP-001",
            "title": "Missing Content-Security-Policy Header",
            "cwe_id": "CWE-1021",
            "cvss_score": 6.1,
            "severity": "HIGH",
            "category": "HTTP Headers",
            "owasp": "A03:2021 - Injection",
            "simple_explanation": "Your website doesn't tell browsers which scripts and resources are allowed to run. This means attackers could inject malicious scripts that steal user data, redirect to phishing sites, or install malware.",
            "technical_detail": "Content-Security-Policy (CSP) is a defense-in-depth mechanism that restricts the origins from which content can be loaded. Without CSP, the browser trusts all inline scripts and external resources, making XSS attacks trivially exploitable.",
            "impact_score": 8,
            "exploit_difficulty": "LOW",
            "real_world_example": "In 2018, British Airways suffered a Magecart attack where malicious JavaScript was injected into their payment page. A strong CSP would have blocked the unauthorized script from executing, preventing the theft of 380,000 credit card details.",
            "fix_instructions": {
                "nginx": "add_header Content-Security-Policy \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';\" always;",
                "apache": "Header always set Content-Security-Policy \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';\"",
                "nodejs": "app.use((req, res, next) => { res.setHeader('Content-Security-Policy', \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'\"); next(); });",
                "iis": "<system.webServer><httpProtocol><customHeaders><add name=\"Content-Security-Policy\" value=\"default-src 'self'\" /></customHeaders></httpProtocol></system.webServer>"
            },
            "priority_timeframe": "7 days",
            "compliance": ["PCI-DSS 6.5.7", "GDPR Art. 32", "NIST SP 800-53 SI-10"]
        },
        "MISSING_HSTS": {
            "id": "VULN-HTTP-002",
            "title": "Missing or Weak HSTS Header",
            "cwe_id": "CWE-319",
            "cvss_score": 7.4,
            "severity": "HIGH",
            "category": "HTTP Headers",
            "owasp": "A02:2021 - Cryptographic Failures",
            "simple_explanation": "Your website doesn't force browsers to always use HTTPS. An attacker on the same network (like public WiFi) could intercept the connection before it upgrades to HTTPS and steal everything the user sends, including passwords and credit card numbers.",
            "technical_detail": "HTTP Strict Transport Security (HSTS) instructs browsers to only communicate over HTTPS. Without HSTS, SSL stripping attacks can downgrade connections to HTTP, exposing all traffic in plaintext.",
            "impact_score": 9,
            "exploit_difficulty": "MEDIUM",
            "real_world_example": "The 'sslstrip' tool by Moxie Marlinspike demonstrated how trivially HTTPS connections can be downgraded on public WiFi. Major sites like PayPal and banking institutions were vulnerable before implementing HSTS.",
            "fix_instructions": {
                "nginx": "add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\" always;",
                "apache": "Header always set Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\"",
                "nodejs": "app.use((req, res, next) => { res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload'); next(); });",
                "iis": "<system.webServer><httpProtocol><customHeaders><add name=\"Strict-Transport-Security\" value=\"max-age=31536000; includeSubDomains; preload\" /></customHeaders></httpProtocol></system.webServer>"
            },
            "priority_timeframe": "24 hours",
            "compliance": ["PCI-DSS 4.1", "HIPAA §164.312(e)", "NIST SP 800-52"]
        },
        "MISSING_X_FRAME_OPTIONS": {
            "id": "VULN-HTTP-003",
            "title": "Missing X-Frame-Options / Clickjacking Protection",
            "cwe_id": "CWE-1021",
            "cvss_score": 4.3,
            "severity": "MEDIUM",
            "category": "HTTP Headers",
            "owasp": "A04:2021 - Insecure Design",
            "simple_explanation": "Your website can be embedded in invisible frames on malicious sites. Attackers can trick users into clicking hidden buttons on your site (like 'Transfer Money' or 'Delete Account') while they think they're clicking something harmless.",
            "technical_detail": "Clickjacking attacks use transparent iframes to overlay the target site on a decoy page. Without X-Frame-Options or CSP frame-ancestors, the browser allows any site to embed your pages.",
            "impact_score": 6,
            "exploit_difficulty": "LOW",
            "real_world_example": "Facebook 'likejacking' attacks tricked millions of users into liking pages without their knowledge by embedding Facebook's Like button in invisible iframes on malicious websites.",
            "fix_instructions": {
                "nginx": "add_header X-Frame-Options \"DENY\" always;",
                "apache": "Header always set X-Frame-Options \"DENY\"",
                "nodejs": "app.use((req, res, next) => { res.setHeader('X-Frame-Options', 'DENY'); next(); });",
                "iis": "<system.webServer><httpProtocol><customHeaders><add name=\"X-Frame-Options\" value=\"DENY\" /></customHeaders></httpProtocol></system.webServer>"
            },
            "priority_timeframe": "7 days",
            "compliance": ["PCI-DSS 6.5.9", "OWASP ASVS V14.4"]
        },
        "MISSING_X_CONTENT_TYPE": {
            "id": "VULN-HTTP-004",
            "title": "Missing X-Content-Type-Options Header",
            "cwe_id": "CWE-16",
            "cvss_score": 5.3,
            "severity": "MEDIUM",
            "category": "HTTP Headers",
            "owasp": "A05:2021 - Security Misconfiguration",
            "simple_explanation": "Browsers might 'guess' the type of files your website serves, which can turn harmless-looking files into executable scripts. An attacker could upload a file that looks like an image but actually runs malicious code.",
            "technical_detail": "MIME type sniffing allows browsers to interpret response content differently from what the Content-Type header specifies. This can lead to XSS when a browser sniffs a text/plain response as text/html.",
            "impact_score": 5,
            "exploit_difficulty": "MEDIUM",
            "real_world_example": "Rosetta Flash (CVE-2014-4671) exploited MIME sniffing to execute Flash-based cross-domain attacks by serving specially crafted content that browsers misinterpreted.",
            "fix_instructions": {
                "nginx": "add_header X-Content-Type-Options \"nosniff\" always;",
                "apache": "Header always set X-Content-Type-Options \"nosniff\"",
                "nodejs": "app.use((req, res, next) => { res.setHeader('X-Content-Type-Options', 'nosniff'); next(); });",
                "iis": "<system.webServer><httpProtocol><customHeaders><add name=\"X-Content-Type-Options\" value=\"nosniff\" /></customHeaders></httpProtocol></system.webServer>"
            },
            "priority_timeframe": "7 days",
            "compliance": ["OWASP ASVS V14.4.3"]
        },
        "MISSING_REFERRER_POLICY": {
            "id": "VULN-HTTP-005",
            "title": "Missing Referrer-Policy Header",
            "cwe_id": "CWE-200",
            "cvss_score": 3.1,
            "severity": "LOW",
            "category": "HTTP Headers",
            "owasp": "A01:2021 - Broken Access Control",
            "simple_explanation": "When users click links on your site, the destination website can see the full URL they came from, which might contain sensitive information like search queries, session tokens, or private page paths.",
            "technical_detail": "The Referer header is sent by default with every request. Without a Referrer-Policy, full URLs including query parameters and paths are leaked to third-party sites, potentially exposing tokens, PII, or internal paths.",
            "impact_score": 4,
            "exploit_difficulty": "LOW",
            "real_world_example": "Healthcare.gov leaked users' health conditions through URL parameters in the Referer header when users clicked on third-party ad links.",
            "fix_instructions": {
                "nginx": "add_header Referrer-Policy \"strict-origin-when-cross-origin\" always;",
                "apache": "Header always set Referrer-Policy \"strict-origin-when-cross-origin\"",
                "nodejs": "app.use((req, res, next) => { res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin'); next(); });",
                "iis": "<system.webServer><httpProtocol><customHeaders><add name=\"Referrer-Policy\" value=\"strict-origin-when-cross-origin\" /></customHeaders></httpProtocol></system.webServer>"
            },
            "priority_timeframe": "30 days",
            "compliance": ["GDPR Art. 25"]
        },
        "MISSING_PERMISSIONS_POLICY": {
            "id": "VULN-HTTP-006",
            "title": "Missing Permissions-Policy Header",
            "cwe_id": "CWE-16",
            "cvss_score": 4.3,
            "severity": "MEDIUM",
            "category": "HTTP Headers",
            "owasp": "A05:2021 - Security Misconfiguration",
            "simple_explanation": "Your website doesn't control which browser features (camera, microphone, location, payment) can be used. Malicious scripts or embedded content could secretly access these sensitive hardware features.",
            "technical_detail": "Permissions-Policy (formerly Feature-Policy) controls which browser APIs are available in the document. Without it, any script can request access to geolocation, camera, microphone, and payment APIs.",
            "impact_score": 5,
            "exploit_difficulty": "MEDIUM",
            "real_world_example": "Malvertising campaigns have used embedded ad iframes to access users' cameras and microphones through websites that didn't restrict permissions via headers.",
            "fix_instructions": {
                "nginx": "add_header Permissions-Policy \"camera=(), microphone=(), geolocation=(), payment=()\" always;",
                "apache": "Header always set Permissions-Policy \"camera=(), microphone=(), geolocation=(), payment=()\"",
                "nodejs": "app.use((req, res, next) => { res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=(), payment=()'); next(); });",
                "iis": "<system.webServer><httpProtocol><customHeaders><add name=\"Permissions-Policy\" value=\"camera=(), microphone=(), geolocation=(), payment=()\" /></customHeaders></httpProtocol></system.webServer>"
            },
            "priority_timeframe": "30 days",
            "compliance": ["OWASP ASVS V14.4"]
        },
        "WEAK_CSP": {
            "id": "VULN-HTTP-007",
            "title": "Weak Content-Security-Policy Configuration",
            "cwe_id": "CWE-1021",
            "cvss_score": 5.4,
            "severity": "MEDIUM",
            "category": "HTTP Headers",
            "owasp": "A03:2021 - Injection",
            "simple_explanation": "Your website has a Content-Security-Policy but it's configured with unsafe directives like 'unsafe-inline' or 'unsafe-eval'. This significantly weakens the protection against script injection attacks.",
            "technical_detail": "CSP with unsafe-inline or unsafe-eval effectively negates most XSS protection. Attackers can still inject and execute arbitrary scripts despite the CSP being present.",
            "impact_score": 6,
            "exploit_difficulty": "LOW",
            "real_world_example": "GitHub found that many of their CSP bypass reports were due to unsafe-inline usage in early deployments. Switching to nonce-based CSP eliminated entire classes of XSS vulnerabilities.",
            "fix_instructions": {
                "nginx": "# Use nonce-based CSP instead of unsafe-inline\nadd_header Content-Security-Policy \"default-src 'self'; script-src 'self' 'nonce-{random}'; style-src 'self' 'nonce-{random}';\" always;",
                "apache": "# Use nonce-based CSP\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self' 'nonce-{random}';\"",
                "nodejs": "const crypto = require('crypto');\nconst nonce = crypto.randomBytes(16).toString('base64');\nres.setHeader('Content-Security-Policy', `script-src 'self' 'nonce-${nonce}'`);",
                "iis": "<!-- Use nonce-based CSP with server-side nonce generation -->"
            },
            "priority_timeframe": "7 days",
            "compliance": ["PCI-DSS 6.5.7", "OWASP ASVS V14.4"]
        },
        "CORS_MISCONFIGURATION": {
            "id": "VULN-HTTP-008",
            "title": "CORS Misconfiguration Detected",
            "cwe_id": "CWE-942",
            "cvss_score": 7.5,
            "severity": "HIGH",
            "category": "HTTP Headers",
            "owasp": "A01:2021 - Broken Access Control",
            "simple_explanation": "Your website allows other websites to make requests to your server and read the responses. Attackers can create a malicious website that steals your users' data by making requests to your server from the victim's browser.",
            "technical_detail": "CORS with Access-Control-Allow-Origin: * or reflecting the Origin header without validation allows any website to make authenticated cross-origin requests and read responses, bypassing the Same-Origin Policy.",
            "impact_score": 8,
            "exploit_difficulty": "LOW",
            "real_world_example": "In 2019, a CORS misconfiguration in a major Bitcoin exchange allowed attackers to steal cryptocurrency by reading API responses from victims' authenticated sessions through a malicious website.",
            "fix_instructions": {
                "nginx": "# Only allow specific trusted origins\nset $cors_origin '';\nif ($http_origin ~* '^https://(www\\.)?yourdomain\\.com$') {\n    set $cors_origin $http_origin;\n}\nadd_header Access-Control-Allow-Origin $cors_origin always;",
                "apache": "SetEnvIf Origin \"^https://(www\\.)?yourdomain\\.com$\" CORS_ALLOW=$0\nHeader always set Access-Control-Allow-Origin \"%{CORS_ALLOW}e\" env=CORS_ALLOW",
                "nodejs": "const allowedOrigins = ['https://yourdomain.com'];\napp.use(cors({ origin: (origin, cb) => cb(null, allowedOrigins.includes(origin)) }));",
                "iis": "<!-- Configure specific origins in web.config -->"
            },
            "priority_timeframe": "24 hours",
            "compliance": ["PCI-DSS 6.5.8", "OWASP ASVS V14.5"]
        },

        # ===== SSL/TLS VULNERABILITIES =====
        "NO_HTTPS": {
            "id": "VULN-SSL-001",
            "title": "No HTTPS Encryption",
            "cwe_id": "CWE-319",
            "cvss_score": 9.1,
            "severity": "CRITICAL",
            "category": "SSL/TLS",
            "owasp": "A02:2021 - Cryptographic Failures",
            "simple_explanation": "Your website sends ALL data in plain text that anyone on the same network can read. Passwords, credit card numbers, personal information - everything is visible to attackers on public WiFi or compromised networks.",
            "technical_detail": "Without TLS encryption, all HTTP traffic is transmitted in cleartext. Passive network sniffing tools like Wireshark can capture all transmitted data including credentials, session cookies, and personal information.",
            "impact_score": 10,
            "exploit_difficulty": "LOW",
            "real_world_example": "The Firesheep browser extension (2010) demonstrated how trivially session hijacking works on unencrypted WiFi networks, stealing Facebook and Twitter sessions of hundreds of thousands of users in cafés worldwide.",
            "fix_instructions": {
                "nginx": "server {\n    listen 443 ssl;\n    ssl_certificate /path/to/cert.pem;\n    ssl_certificate_key /path/to/key.pem;\n    ssl_protocols TLSv1.2 TLSv1.3;\n}\nserver {\n    listen 80;\n    return 301 https://$host$request_uri;\n}",
                "apache": "SSLEngine on\nSSLCertificateFile /path/to/cert.pem\nSSLCertificateKeyFile /path/to/key.pem\nSSLProtocol all -SSLv3 -TLSv1 -TLSv1.1",
                "nodejs": "const https = require('https');\nconst fs = require('fs');\nhttps.createServer({\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n}, app).listen(443);",
                "iis": "<!-- Install SSL certificate through IIS Manager > Server Certificates -->"
            },
            "priority_timeframe": "IMMEDIATE",
            "compliance": ["PCI-DSS 4.1", "HIPAA §164.312(e)", "GDPR Art. 32", "SOC 2 CC6.1"]
        },
        "EXPIRED_CERTIFICATE": {
            "id": "VULN-SSL-002",
            "title": "Expired SSL Certificate",
            "cwe_id": "CWE-295",
            "cvss_score": 7.4,
            "severity": "CRITICAL",
            "category": "SSL/TLS",
            "owasp": "A02:2021 - Cryptographic Failures",
            "simple_explanation": "Your SSL certificate has expired. Visitors see scary browser warnings and most will leave immediately. Worse, expired certificates can be exploited in man-in-the-middle attacks since browsers may bypass validation if users click 'proceed anyway'.",
            "technical_detail": "Expired certificates break the chain of trust. While browsers warn users, many organizations' certificate expiry leads to downtime, user trust degradation, and potential MITM if users override warnings.",
            "impact_score": 9,
            "exploit_difficulty": "LOW",
            "real_world_example": "In 2020, Microsoft Teams suffered a global outage because an authentication certificate expired. Ericsson's expired certificate caused a UK-wide cellular outage affecting 32 million O2 customers.",
            "fix_instructions": {
                "nginx": "# Renew certificate (Let's Encrypt example)\ncertbot renew\n# Or set up auto-renewal\ncrontab -e\n0 0 1 * * certbot renew --quiet",
                "apache": "# Renew certificate\ncertbot renew\n# Auto-renewal cron\n0 0 1 * * /usr/bin/certbot renew --quiet",
                "nodejs": "// Use Let's Encrypt with auto-renewal\n// npm install greenlock-express\nrequire('greenlock-express').init({ packageRoot: __dirname, maintainerEmail: 'you@example.com' });",
                "iis": "<!-- Renew certificate through IIS Manager or certbot for IIS -->"
            },
            "priority_timeframe": "IMMEDIATE",
            "compliance": ["PCI-DSS 4.1", "SOC 2 CC6.1"]
        },
        "WEAK_TLS_VERSION": {
            "id": "VULN-SSL-003",
            "title": "Outdated/Weak TLS Protocol Version",
            "cwe_id": "CWE-326",
            "cvss_score": 7.5,
            "severity": "HIGH",
            "category": "SSL/TLS",
            "owasp": "A02:2021 - Cryptographic Failures",
            "simple_explanation": "Your server supports old encryption protocols (TLS 1.0 or 1.1) that have known security flaws. Attackers can use techniques like POODLE or BEAST to decrypt the 'secure' connection and read sensitive data.",
            "technical_detail": "TLS 1.0 and 1.1 are vulnerable to BEAST (CVE-2011-3389), POODLE (CVE-2014-3566), and Lucky Thirteen attacks. All major browsers have deprecated these protocols. Only TLS 1.2+ should be used.",
            "impact_score": 8,
            "exploit_difficulty": "MEDIUM",
            "real_world_example": "The POODLE attack (2014) exploited TLS 1.0's CBC mode to decrypt HTTPS traffic byte-by-byte. This led all major browsers and PCI-DSS to mandate TLS 1.2 as the minimum version.",
            "fix_instructions": {
                "nginx": "ssl_protocols TLSv1.2 TLSv1.3;\nssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384;",
                "apache": "SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1\nSSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256",
                "nodejs": "const tls = require('tls');\ntls.DEFAULT_MIN_VERSION = 'TLSv1.2';\n// Or in https.createServer options:\n{ minVersion: 'TLSv1.2' }",
                "iis": "<!-- Disable old protocols in Registry: HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols -->"
            },
            "priority_timeframe": "7 days",
            "compliance": ["PCI-DSS 4.1", "NIST SP 800-52 Rev.2", "HIPAA §164.312(e)"]
        },
        "WEAK_CIPHER_SUITE": {
            "id": "VULN-SSL-004",
            "title": "Weak Cipher Suites Enabled",
            "cwe_id": "CWE-327",
            "cvss_score": 5.9,
            "severity": "MEDIUM",
            "category": "SSL/TLS",
            "owasp": "A02:2021 - Cryptographic Failures",
            "simple_explanation": "Your server accepts weak encryption algorithms (like RC4 or DES) that can be cracked. Even though you're using HTTPS, the actual encryption is so weak that determined attackers can break it and read your data.",
            "technical_detail": "Weak ciphers like RC4, DES, 3DES, or those using MD5/SHA-1 for integrity have known cryptographic weaknesses. CBC-mode ciphers are vulnerable to timing attacks (Lucky Thirteen).",
            "impact_score": 6,
            "exploit_difficulty": "HIGH",
            "real_world_example": "The RC4 cipher was broken in 2015 with the 'Bar Mitzvah Attack' and subsequent research showing plaintext recovery from RC4-encrypted TLS sessions within 52 hours.",
            "fix_instructions": {
                "nginx": "ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305';\nssl_prefer_server_ciphers on;",
                "apache": "SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384\nSSLHonorCipherOrder on",
                "nodejs": "https.createServer({ ciphers: 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256' });",
                "iis": "<!-- Configure cipher suite order via Group Policy or IIS Crypto tool -->"
            },
            "priority_timeframe": "7 days",
            "compliance": ["PCI-DSS 4.1", "FIPS 140-2"]
        },
        "CERTIFICATE_EXPIRING_SOON": {
            "id": "VULN-SSL-005",
            "title": "SSL Certificate Expiring Soon",
            "cwe_id": "CWE-298",
            "cvss_score": 3.7,
            "severity": "LOW",
            "category": "SSL/TLS",
            "owasp": "A02:2021 - Cryptographic Failures",
            "simple_explanation": "Your SSL certificate is about to expire. If it expires, all visitors will see security warnings and your website will effectively become inaccessible to most users.",
            "technical_detail": "Certificate expiry is a common operational issue. Auto-renewal should be configured to prevent service disruption.",
            "impact_score": 4,
            "exploit_difficulty": "NONE",
            "real_world_example": "LinkedIn, Spotify, and dozens of major sites have suffered outages due to forgotten certificate renewals.",
            "fix_instructions": {
                "nginx": "# Set up Let's Encrypt auto-renewal\ncertbot renew --dry-run\n# Add to crontab: 0 0 * * * certbot renew --quiet --post-hook 'systemctl reload nginx'",
                "apache": "certbot renew --dry-run\n# Crontab: 0 0 * * * certbot renew --quiet --post-hook 'systemctl reload apache2'",
                "nodejs": "// Use greenlock-express for auto-renewal\nrequire('greenlock-express').init({ maintainerEmail: 'you@example.com' });",
                "iis": "<!-- Use win-acme for auto-renewal on Windows -->"
            },
            "priority_timeframe": "7 days",
            "compliance": ["PCI-DSS 4.1"]
        },

        # ===== DNS VULNERABILITIES =====
        "MISSING_SPF": {
            "id": "VULN-DNS-001",
            "title": "Missing SPF Record",
            "cwe_id": "CWE-290",
            "cvss_score": 5.3,
            "severity": "HIGH",
            "category": "DNS Security",
            "owasp": "A05:2021 - Security Misconfiguration",
            "simple_explanation": "Anyone can send emails pretending to be from your domain. Without SPF, there's no way for email servers to verify if an email from your-domain.com actually came from your servers. Attackers actively use this for phishing.",
            "technical_detail": "SPF (Sender Policy Framework) defines which mail servers are authorized to send email for your domain via DNS TXT records. Without SPF, any SMTP server can forge your domain in the From header.",
            "impact_score": 7,
            "exploit_difficulty": "LOW",
            "real_world_example": "Business Email Compromise (BEC) attacks caused $1.8 billion in losses in 2020 (FBI IC3). Many attacks succeed because victim domains lack SPF records, allowing perfect domain spoofing.",
            "fix_instructions": {
                "nginx": "# Add DNS TXT record (not a web server config)\n# Example SPF record:\nyour-domain.com. IN TXT \"v=spf1 include:_spf.google.com include:mailgun.org ~all\"",
                "apache": "# Add DNS TXT record via your DNS provider\n# your-domain.com TXT \"v=spf1 ip4:YOUR_MAIL_SERVER_IP ~all\"",
                "nodejs": "// SPF is configured in DNS, not application code\n// Add TXT record: v=spf1 include:_spf.google.com ~all",
                "iis": "<!-- Add SPF TXT record in your DNS zone -->"
            },
            "priority_timeframe": "7 days",
            "compliance": ["DMARC RFC 7489", "NIST SP 800-177"]
        },
        "MISSING_DMARC": {
            "id": "VULN-DNS-002",
            "title": "Missing DMARC Record",
            "cwe_id": "CWE-290",
            "cvss_score": 5.3,
            "severity": "HIGH",
            "category": "DNS Security",
            "owasp": "A05:2021 - Security Misconfiguration",
            "simple_explanation": "Even with SPF, your domain is still vulnerable to email spoofing. DMARC tells receiving mail servers what to do when emails fail authentication - without it, spoofed emails from your domain may still reach inboxes.",
            "technical_detail": "DMARC (Domain-based Message Authentication, Reporting & Conformance) builds on SPF and DKIM to provide domain-level email authentication. Without DMARC, spoofed emails may still pass through even with SPF configured.",
            "impact_score": 7,
            "exploit_difficulty": "LOW",
            "real_world_example": "In 2016, the Democratic National Committee was targeted by spear-phishing emails that spoofed internal domains. Proper DMARC implementation would have flagged or blocked these spoofed messages.",
            "fix_instructions": {
                "nginx": "# Add DNS TXT record:\n_dmarc.your-domain.com. IN TXT \"v=DMARC1; p=reject; rua=mailto:dmarc@your-domain.com; ruf=mailto:dmarc-forensic@your-domain.com; pct=100\"",
                "apache": "# DNS TXT record:\n# _dmarc.your-domain.com TXT \"v=DMARC1; p=quarantine; rua=mailto:dmarc-reports@your-domain.com\"",
                "nodejs": "// DMARC is configured in DNS\n// Add _dmarc.your-domain.com TXT \"v=DMARC1; p=reject; rua=mailto:reports@your-domain.com\"",
                "iis": "<!-- Add DMARC TXT record in your DNS zone file -->"
            },
            "priority_timeframe": "7 days",
            "compliance": ["NIST SP 800-177", "BOD 18-01 (US Govt)"]
        },
        "MISSING_DNSSEC": {
            "id": "VULN-DNS-003",
            "title": "DNSSEC Not Enabled",
            "cwe_id": "CWE-350",
            "cvss_score": 4.3,
            "severity": "MEDIUM",
            "category": "DNS Security",
            "owasp": "A05:2021 - Security Misconfiguration",
            "simple_explanation": "Your domain's DNS responses aren't cryptographically signed. An attacker could poison DNS caches and redirect your visitors to malicious servers without anyone knowing - they'd still see your domain name in the browser.",
            "technical_detail": "DNSSEC adds cryptographic signatures to DNS records, preventing DNS spoofing and cache poisoning attacks. Without DNSSEC, DNS responses can be forged by on-path attackers.",
            "impact_score": 5,
            "exploit_difficulty": "HIGH",
            "real_world_example": "The Kaminsky attack (2008) demonstrated that DNS cache poisoning was far easier than previously thought, potentially redirecting all traffic for a domain to attacker-controlled servers.",
            "fix_instructions": {
                "nginx": "# DNSSEC is configured at the DNS registrar/provider level\n# 1. Enable DNSSEC signing at your DNS provider\n# 2. Add DS records at your registrar\n# Most cloud DNS providers support one-click DNSSEC",
                "apache": "# Enable DNSSEC through your DNS hosting provider\n# Cloudflare, Route53, and Google Cloud DNS all support DNSSEC",
                "nodejs": "// DNSSEC is a DNS infrastructure configuration\n// Contact your DNS provider to enable DNSSEC signing",
                "iis": "<!-- Enable DNSSEC in Windows DNS Server Manager or cloud DNS provider -->"
            },
            "priority_timeframe": "30 days",
            "compliance": ["NIST SP 800-81-2"]
        },

        # ===== SERVER CONFIGURATION VULNERABILITIES =====
        "SERVER_VERSION_DISCLOSURE": {
            "id": "VULN-SRV-001",
            "title": "Server Version Information Disclosure",
            "cwe_id": "CWE-200",
            "cvss_score": 5.3,
            "severity": "MEDIUM",
            "category": "Server Configuration",
            "owasp": "A05:2021 - Security Misconfiguration",
            "simple_explanation": "Your server is advertising its exact software version to everyone. This gives attackers a roadmap - they can look up exactly which vulnerabilities affect your specific version and target those exploits.",
            "technical_detail": "Server headers exposing version information (e.g., 'Apache/2.4.29' or 'PHP/7.2.1') allow attackers to enumerate exact software versions and cross-reference with CVE databases for known exploits.",
            "impact_score": 4,
            "exploit_difficulty": "LOW",
            "real_world_example": "The Equifax breach (2017) exploited a known Apache Struts vulnerability (CVE-2017-5638). Version disclosure in headers made it trivial for attackers to identify the vulnerable version.",
            "fix_instructions": {
                "nginx": "server_tokens off;\n# In http block:\nmore_clear_headers Server;",
                "apache": "ServerTokens Prod\nServerSignature Off\n# In httpd.conf\nHeader unset X-Powered-By",
                "nodejs": "app.disable('x-powered-by');\n// Or use helmet:\nconst helmet = require('helmet');\napp.use(helmet.hidePoweredBy());",
                "iis": "<system.webServer><security><requestFiltering removeServerHeader=\"true\" /></security></system.webServer>"
            },
            "priority_timeframe": "7 days",
            "compliance": ["PCI-DSS 2.2.5", "CIS Benchmark"]
        },
        "WAF_NOT_DETECTED": {
            "id": "VULN-SRV-002",
            "title": "No Web Application Firewall (WAF) Detected",
            "cwe_id": "CWE-693",
            "cvss_score": 3.7,
            "severity": "LOW",
            "category": "Server Configuration",
            "owasp": "A05:2021 - Security Misconfiguration",
            "simple_explanation": "Your website doesn't appear to be protected by a Web Application Firewall. A WAF acts as a security guard that filters out malicious traffic before it reaches your server, blocking common attacks like SQL injection and XSS.",
            "technical_detail": "WAFs provide an additional defense layer by inspecting HTTP requests for known attack patterns. While not a replacement for secure code, WAFs significantly reduce the attack surface and can provide virtual patching.",
            "impact_score": 3,
            "exploit_difficulty": "NONE",
            "real_world_example": "Many organizations use Cloudflare, AWS WAF, or ModSecurity as a defense-in-depth measure. Cloudflare alone blocks an average of 70 billion cyber threats per day.",
            "fix_instructions": {
                "nginx": "# Install ModSecurity WAF\napt install libmodsecurity3\n# Or use Cloudflare free tier as reverse proxy WAF",
                "apache": "# Enable mod_security\na2enmod security2\n# Install OWASP Core Rule Set\ngit clone https://github.com/coreruleset/coreruleset",
                "nodejs": "// Use express-rate-limit + helmet as basic protection\n// For enterprise: deploy behind Cloudflare, AWS WAF, or Azure Front Door",
                "iis": "<!-- Install IIS with URL Rewrite + Application Request Routing -->"
            },
            "priority_timeframe": "30 days",
            "compliance": ["PCI-DSS 6.6"]
        },
    }


class AdvancedVulnerabilityEngine:
    """
    Professional-grade vulnerability analysis engine.
    Enriches scan results with deep explanations, risk prioritization,
    and actionable remediation guidance.
    """

    def __init__(self):
        self.knowledge = VulnerabilityKnowledge.VULNERABILITIES
        self.waf_signatures = {
            "Cloudflare": ["cf-ray", "cf-cache-status", "__cfduid", "cf-request-id"],
            "AWS WAF": ["x-amzn-requestid", "x-amz-cf-id"],
            "Akamai": ["x-akamai-transformed", "akamai"],
            "Imperva/Incapsula": ["x-cdn", "incap_ses", "visid_incap"],
            "Sucuri": ["x-sucuri-id", "x-sucuri-cache"],
            "F5 BIG-IP": ["x-cnection", "bigipserver"],
            "Barracuda": ["barra_counter_session"],
            "ModSecurity": ["mod_security", "NOYB"],
        }

    def analyze(
        self,
        http_scan: Dict,
        ssl_scan: Dict,
        dns_scan: Dict,
        tech_scan: Dict
    ) -> Dict[str, Any]:
        """
        Perform deep vulnerability analysis on all scan results.

        Returns enriched vulnerability report with:
        - Detailed vulnerability explanations
        - CWE/CVE mappings
        - Impact scoring and exploit difficulty
        - Real-world examples
        - Fix instructions for nginx/apache/nodejs/iis
        - Risk prioritization with timeframes
        - Compliance mapping
        - Security scorecard
        """
        vulnerabilities = []

        # Analyze HTTP headers
        vulnerabilities.extend(self._analyze_http(http_scan))

        # Analyze SSL/TLS
        vulnerabilities.extend(self._analyze_ssl(ssl_scan))

        # Analyze DNS
        vulnerabilities.extend(self._analyze_dns(dns_scan))

        # Analyze server configuration
        vulnerabilities.extend(self._analyze_server(http_scan, tech_scan))

        # WAF detection
        waf_result = self._detect_waf(http_scan)

        # Sort by CVSS score descending
        vulnerabilities.sort(key=lambda v: v.get("cvss_score", 0), reverse=True)

        # Build risk prioritization dashboard
        prioritization = self._build_prioritization(vulnerabilities)

        # Build security scorecard
        scorecard = self._build_scorecard(vulnerabilities, http_scan, ssl_scan, dns_scan, tech_scan)

        # Compliance summary
        compliance = self._build_compliance_summary(vulnerabilities)

        return {
            "analysis_timestamp": datetime.utcnow().isoformat(),
            "total_vulnerabilities": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "waf_detection": waf_result,
            "risk_prioritization": prioritization,
            "security_scorecard": scorecard,
            "compliance_summary": compliance,
            "severity_counts": {
                "critical": sum(1 for v in vulnerabilities if v["severity"] == "CRITICAL"),
                "high": sum(1 for v in vulnerabilities if v["severity"] == "HIGH"),
                "medium": sum(1 for v in vulnerabilities if v["severity"] == "MEDIUM"),
                "low": sum(1 for v in vulnerabilities if v["severity"] == "LOW"),
            }
        }

    def _analyze_http(self, http_scan: Dict) -> List[Dict]:
        """Analyze HTTP header vulnerabilities with deep explanations."""
        vulns = []
        if not http_scan.get("success"):
            return vulns

        header_analysis = http_scan.get("header_analysis", {})

        header_vuln_map = {
            "Content-Security-Policy": ("MISSING_CSP", "WEAK_CSP"),
            "Strict-Transport-Security": ("MISSING_HSTS", None),
            "X-Frame-Options": ("MISSING_X_FRAME_OPTIONS", None),
            "X-Content-Type-Options": ("MISSING_X_CONTENT_TYPE", None),
            "Referrer-Policy": ("MISSING_REFERRER_POLICY", None),
            "Permissions-Policy": ("MISSING_PERMISSIONS_POLICY", None),
        }

        for header_name, (missing_key, weak_key) in header_vuln_map.items():
            if header_name in header_analysis:
                analysis = header_analysis[header_name]
                if not analysis.get("present"):
                    if missing_key in self.knowledge:
                        vulns.append(self._enrich_vulnerability(missing_key, {
                            "detected_value": "Not present",
                            "header": header_name
                        }))
                elif weak_key and analysis.get("score", 100) < 70:
                    if weak_key in self.knowledge:
                        vulns.append(self._enrich_vulnerability(weak_key, {
                            "detected_value": analysis.get("value", ""),
                            "score": analysis.get("score", 0),
                            "header": header_name
                        }))

        # Check CORS
        all_headers = http_scan.get("all_headers", {})
        cors_origin = all_headers.get("Access-Control-Allow-Origin", "")
        if cors_origin == "*":
            vulns.append(self._enrich_vulnerability("CORS_MISCONFIGURATION", {
                "detected_value": cors_origin
            }))

        return vulns

    def _analyze_ssl(self, ssl_scan: Dict) -> List[Dict]:
        """Analyze SSL/TLS vulnerabilities with deep explanations."""
        vulns = []

        if ssl_scan.get("error") and "not HTTPS" in str(ssl_scan.get("error", "")):
            vulns.append(self._enrich_vulnerability("NO_HTTPS", {}))
            return vulns

        if not ssl_scan.get("success"):
            return vulns

        cert = ssl_scan.get("certificate", {})

        # Expired certificate
        if cert.get("expired"):
            vulns.append(self._enrich_vulnerability("EXPIRED_CERTIFICATE", {
                "expiry_date": cert.get("valid_to", "Unknown")
            }))

        # Expiring soon
        days_left = cert.get("days_until_expiry", 999)
        if 0 < days_left <= 30:
            vulns.append(self._enrich_vulnerability("CERTIFICATE_EXPIRING_SOON", {
                "days_remaining": days_left,
                "expiry_date": cert.get("valid_to", "Unknown")
            }))

        # Weak TLS
        tls_version = ssl_scan.get("tls_version", "")
        if tls_version and tls_version in ["TLSv1.0", "TLSv1.1", "SSLv3"]:
            vulns.append(self._enrich_vulnerability("WEAK_TLS_VERSION", {
                "detected_version": tls_version
            }))

        # Weak ciphers
        cipher = ssl_scan.get("cipher", "")
        if cipher:
            cipher_name = cipher[0] if isinstance(cipher, (list, tuple)) else str(cipher)
            weak_indicators = ["RC4", "DES", "MD5", "NULL", "EXPORT", "anon"]
            if any(w in cipher_name.upper() for w in weak_indicators):
                vulns.append(self._enrich_vulnerability("WEAK_CIPHER_SUITE", {
                    "detected_cipher": cipher_name
                }))

        # Missing HSTS (from SSL perspective)
        if not ssl_scan.get("hsts", {}).get("present"):
            has_hsts_vuln = any(v.get("vuln_key") == "MISSING_HSTS" for v in vulns)
            if not has_hsts_vuln:
                vulns.append(self._enrich_vulnerability("MISSING_HSTS", {
                    "detected_value": "HSTS not present in SSL check"
                }))

        return vulns

    def _analyze_dns(self, dns_scan: Dict) -> List[Dict]:
        """Analyze DNS security vulnerabilities."""
        vulns = []
        if not dns_scan.get("success"):
            return vulns

        if not dns_scan.get("spf", {}).get("present"):
            vulns.append(self._enrich_vulnerability("MISSING_SPF", {}))

        if not dns_scan.get("dmarc", {}).get("present"):
            vulns.append(self._enrich_vulnerability("MISSING_DMARC", {}))

        if not dns_scan.get("dnssec", {}).get("enabled"):
            vulns.append(self._enrich_vulnerability("MISSING_DNSSEC", {}))

        return vulns

    def _analyze_server(self, http_scan: Dict, tech_scan: Dict) -> List[Dict]:
        """Analyze server configuration vulnerabilities."""
        vulns = []

        # Server version disclosure
        if tech_scan.get("success") and tech_scan.get("web_server_version"):
            vulns.append(self._enrich_vulnerability("SERVER_VERSION_DISCLOSURE", {
                "server": tech_scan.get("web_server", "Unknown"),
                "version": tech_scan.get("web_server_version", "Unknown")
            }))

        return vulns

    def _detect_waf(self, http_scan: Dict) -> Dict:
        """Detect Web Application Firewall presence."""
        all_headers = http_scan.get("all_headers", {})
        if not all_headers:
            all_headers = {}

        detected_wafs = []
        headers_str = str(all_headers).lower()

        for waf_name, signatures in self.waf_signatures.items():
            for sig in signatures:
                if sig.lower() in headers_str:
                    detected_wafs.append(waf_name)
                    break

        has_waf = len(detected_wafs) > 0

        result = {
            "waf_detected": has_waf,
            "detected_wafs": detected_wafs,
            "protection_level": "PROTECTED" if has_waf else "UNPROTECTED"
        }

        if not has_waf:
            result["recommendation"] = self.knowledge.get("WAF_NOT_DETECTED", {})

        return result

    def _enrich_vulnerability(self, vuln_key: str, context: Dict) -> Dict:
        """Enrich a vulnerability with full knowledge base data."""
        kb = self.knowledge.get(vuln_key, {})
        return {
            "vuln_key": vuln_key,
            "id": kb.get("id", "UNKNOWN"),
            "title": kb.get("title", vuln_key),
            "cwe_id": kb.get("cwe_id", ""),
            "cvss_score": kb.get("cvss_score", 0),
            "severity": kb.get("severity", "UNKNOWN"),
            "category": kb.get("category", "Unknown"),
            "owasp": kb.get("owasp", ""),
            "simple_explanation": kb.get("simple_explanation", ""),
            "technical_detail": kb.get("technical_detail", ""),
            "impact_score": kb.get("impact_score", 0),
            "exploit_difficulty": kb.get("exploit_difficulty", "UNKNOWN"),
            "real_world_example": kb.get("real_world_example", ""),
            "fix_instructions": kb.get("fix_instructions", {}),
            "priority_timeframe": kb.get("priority_timeframe", "N/A"),
            "compliance": kb.get("compliance", []),
            "context": context
        }

    def _build_prioritization(self, vulnerabilities: List[Dict]) -> Dict:
        """Build risk prioritization dashboard."""
        immediate = []
        within_24h = []
        within_7d = []
        within_30d = []
        consider = []

        for vuln in vulnerabilities:
            entry = {
                "id": vuln["id"],
                "title": vuln["title"],
                "severity": vuln["severity"],
                "cvss_score": vuln["cvss_score"]
            }
            tf = vuln.get("priority_timeframe", "N/A")
            if tf == "IMMEDIATE":
                immediate.append(entry)
            elif "24 hour" in tf:
                within_24h.append(entry)
            elif "7 day" in tf:
                within_7d.append(entry)
            elif "30 day" in tf:
                within_30d.append(entry)
            else:
                consider.append(entry)

        return {
            "immediate": immediate,
            "within_24_hours": within_24h,
            "within_7_days": within_7d,
            "within_30_days": within_30d,
            "consider": consider,
            "total_action_items": len(vulnerabilities)
        }

    def _build_scorecard(
        self,
        vulnerabilities: List[Dict],
        http_scan: Dict,
        ssl_scan: Dict,
        dns_scan: Dict,
        tech_scan: Dict
    ) -> Dict:
        """Build user-friendly security scorecard."""
        categories = {
            "Transport Security": {"score": 100, "grade": "A", "issues": []},
            "Header Security": {"score": 100, "grade": "A", "issues": []},
            "DNS & Email Security": {"score": 100, "grade": "A", "issues": []},
            "Server Hardening": {"score": 100, "grade": "A", "issues": []},
            "WAF Protection": {"score": 100, "grade": "A", "issues": []},
        }

        for vuln in vulnerabilities:
            cat = vuln.get("category", "")
            deduction = vuln.get("impact_score", 0) * 3

            if cat == "SSL/TLS":
                categories["Transport Security"]["score"] = max(0, categories["Transport Security"]["score"] - deduction)
                categories["Transport Security"]["issues"].append(vuln["title"])
            elif cat == "HTTP Headers":
                categories["Header Security"]["score"] = max(0, categories["Header Security"]["score"] - deduction)
                categories["Header Security"]["issues"].append(vuln["title"])
            elif cat == "DNS Security":
                categories["DNS & Email Security"]["score"] = max(0, categories["DNS & Email Security"]["score"] - deduction)
                categories["DNS & Email Security"]["issues"].append(vuln["title"])
            elif cat == "Server Configuration":
                categories["Server Hardening"]["score"] = max(0, categories["Server Hardening"]["score"] - deduction)
                categories["Server Hardening"]["issues"].append(vuln["title"])

        # Assign grades
        for cat_name, cat_data in categories.items():
            score = cat_data["score"]
            if score >= 90:
                cat_data["grade"] = "A"
            elif score >= 75:
                cat_data["grade"] = "B"
            elif score >= 60:
                cat_data["grade"] = "C"
            elif score >= 40:
                cat_data["grade"] = "D"
            else:
                cat_data["grade"] = "F"

        # Overall score
        overall = sum(c["score"] for c in categories.values()) / len(categories)

        return {
            "overall_score": round(overall),
            "overall_grade": "A" if overall >= 90 else "B" if overall >= 75 else "C" if overall >= 60 else "D" if overall >= 40 else "F",
            "categories": categories
        }

    def _build_compliance_summary(self, vulnerabilities: List[Dict]) -> Dict:
        """Build compliance framework summary."""
        frameworks = {
            "PCI-DSS": {"status": "COMPLIANT", "violations": [], "description": "Payment Card Industry Data Security Standard"},
            "GDPR": {"status": "COMPLIANT", "violations": [], "description": "General Data Protection Regulation (EU)"},
            "HIPAA": {"status": "COMPLIANT", "violations": [], "description": "Health Insurance Portability and Accountability Act"},
            "SOC 2": {"status": "COMPLIANT", "violations": [], "description": "Service Organization Control Type 2"},
            "NIST": {"status": "COMPLIANT", "violations": [], "description": "NIST Cybersecurity Framework"},
            "OWASP ASVS": {"status": "COMPLIANT", "violations": [], "description": "OWASP Application Security Verification Standard"},
        }

        for vuln in vulnerabilities:
            for comp in vuln.get("compliance", []):
                for fw_name in frameworks:
                    if fw_name.lower().replace("-", "").replace(" ", "") in comp.lower().replace("-", "").replace(" ", ""):
                        frameworks[fw_name]["violations"].append({
                            "vuln_id": vuln["id"],
                            "title": vuln["title"],
                            "requirement": comp,
                            "severity": vuln["severity"]
                        })
                        frameworks[fw_name]["status"] = "NON-COMPLIANT"

        compliant_count = sum(1 for f in frameworks.values() if f["status"] == "COMPLIANT")

        return {
            "frameworks": frameworks,
            "compliant_count": compliant_count,
            "total_frameworks": len(frameworks),
            "compliance_percentage": round((compliant_count / len(frameworks)) * 100)
        }
